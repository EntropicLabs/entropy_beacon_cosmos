use cosmwasm_std::{to_binary, Addr, Binary, Coin, CosmosMsg, StdError, Uint128, WasmMsg};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use crate::msg::ExecuteMsg;

/// Message for updating the configuration of the beacon contract
/// This has can only be called by the owner of the contract
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct UpdateConfigMsg {
    pub whitelist_deposit_amt: Uint128,
    pub key_activation_delay: u64,
    pub protocol_fee: u64,
    pub submitter_share: u64,
}

/// The struct that is used to represent entropy requests to the Beacon contract.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct RequestEntropyMsg {
    /// The amount of gas that has been provisioned for the callback message.
    pub callback_gas_limit: u64,
    /// The address to send the callback message to.
    pub callback_address: Addr,
    /// Arbitrary data to be included in the callback message.
    /// Can be decoded by the callback contract.
    pub callback_msg: Binary,
}

/// The struct that represents callbacks or "responses" from the Beacon contract.
/// Contains both the callback message specified in the request, and the entropy
/// that was returned generated by the network.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct EntropyCallbackMsg {
    /// The entropy that was generated by the network, in a byte array.
    /// The length of the byte array is 64 elements, meaning that there are
    /// 64 total bytes of entropy.
    pub entropy: Vec<u8>,
    /// The original address that submitted the request for entropy. This
    /// should be used to verify that the callback message was generated by
    /// the requester, or by a trusted other contract.
    pub requester: Addr,
    /// The callback message that was specified in the request. The structure
    /// of this Binary is unknown by the Beacon contract, and it is up to your
    /// contract to correctly decode it.
    pub msg: Binary,
}

/// A convinience struct that smoothens the process of creating a request for
/// entropy from the Beacon contract.
///
/// # Example
/// ```
/// use entropy_beacon_cosmos::EntropyRequest;
///
/// let request = EntropyRequest {
///     callback_gas_limit: 100,
///     callback_address: Addr::unchecked("example_contract_address"),
///     funds: vec![Coin{denom: "uluna", amount: 1}],
///     callback_msg: ExampleResponseStruct{
///         example_field: "example_value".to_string(),
///     },
/// };
/// // Later, when submitting the request to the Beacon contract in a contract call:
/// let beacon_addr = Addr::unchecked("beacon_contract_address");
/// Ok(Response::new().add_message(request.into_cosmos(beacon_addr)?))
/// ```
pub struct EntropyRequest<T>
where
    T: Serialize,
{
    /// The amount of gas that has been provisioned for the callback message.
    pub callback_gas_limit: u64,
    /// The address to send the callback message to.
    pub callback_address: Addr,
    /// The funds to be sent alongside the request - to provide callback gas and other fees.
    pub funds: Vec<Coin>,
    /// Arbitrary data to be included in the callback message.
    pub callback_msg: T,
}
impl<T> EntropyRequest<T>
where
    T: Serialize,
{
    /// Creates a CosmosMsg that will execute the request on the Beacon contract,
    /// whose address is provided as the first argument.
    pub fn into_cosmos(self, beacon_addr: Addr) -> Result<CosmosMsg, StdError> {
        Ok(CosmosMsg::Wasm(WasmMsg::Execute {
            contract_addr: beacon_addr.to_string(),
            msg: to_binary(&ExecuteMsg::RequestEntropy(RequestEntropyMsg {
                callback_gas_limit: self.callback_gas_limit,
                callback_address: self.callback_address,
                callback_msg: to_binary(&self.callback_msg)?,
            }))?,
            funds: self.funds,
        }))
    }
}

pub fn calculate_gas_cost(gas_amount: u64) -> Uint128 {
    let gas_price = 15u64;
    let gas_cost = gas_amount * gas_price;
    Uint128::from(gas_cost / 100u64 + 1u64)
}
